import { describe, it, expect } from "bun:test";
import { generateOpenAPI } from "./openapi.ts";
import { SCHEMAS } from "./decorators.ts";

describe("generateOpenAPI", () => {
  it("should generate a default OpenAPI spec with default options", () => {
    const spec = generateOpenAPI({}, { getTargets: () => new Set() } as any);

    expect(spec.openapi).toBe("3.1.0");
    expect(spec.info.title).toBe("Generated API");
    expect(spec.info.version).toBe("1.0.0");
    expect(spec.info.description).toBe(
      "API documentation generated by @di-framework/di-framework-http.",
    );
    expect(spec.paths).toEqual({});
    expect(spec.components.schemas).toEqual({});
  });

  it("should use provided options in the OpenAPI spec", () => {
    const options = {
      title: "Custom API",
      version: "2.0.0",
      description: "Custom description",
    };
    const spec = generateOpenAPI(options, {
      getTargets: () => new Set(),
    } as any);

    expect(spec.info.title).toBe("Custom API");
    expect(spec.info.version).toBe("2.0.0");
    expect(spec.info.description).toBe("Custom description");
  });

  it("should correctly map a registry with controllers and endpoints", () => {
    // Mocking the structure that decorators create
    const mockController = class TestController {};
    // @ts-ignore
    mockController.post = () => {};
    // @ts-ignore
    mockController.post.isEndpoint = true;
    // @ts-ignore
    mockController.post.path = "/test";
    // @ts-ignore
    mockController.post.method = "post";
    // @ts-ignore
    mockController.post.metadata = {
      summary: "Test Summary",
      description: "Test Description",
      requestBody: { content: { "application/json": {} } },
      responses: { "201": { description: "Created" } },
    };

    const registry = { getTargets: () => new Set([mockController]) } as any;
    const spec = generateOpenAPI({}, registry);

    expect(spec.paths["/test"]).toBeDefined();
    expect(spec.paths["/test"].post).toBeDefined();
    const operation = spec.paths["/test"].post;
    expect(operation.summary).toBe("Test Summary");
    expect(operation.description).toBe("Test Description");
    expect(operation.operationId).toBe("TestController.post");
    expect(operation.requestBody).toBeDefined();
    expect(operation.responses["201"]).toBeDefined();
  });

  it("should handle endpoints without metadata", () => {
    const mockController = class SimpleController {};
    // @ts-ignore
    mockController.get = () => {};
    // @ts-ignore
    mockController.get.isEndpoint = true;
    // @ts-ignore
    mockController.get.path = "/simple";
    // @ts-ignore
    mockController.get.method = "get";

    const registry = { getTargets: () => new Set([mockController]) } as any;
    const spec = generateOpenAPI({}, registry);

    const operation = spec.paths["/simple"].get;
    expect(operation.summary).toBe("get"); // defaults to property key
    expect(operation.responses["200"]).toBeDefined(); // default response
    expect(operation.responses["200"].description).toBe("OK");
  });

  it("should handle multiple endpoints on the same path", () => {
    const mockController = class MultiController {};
    // @ts-ignore
    mockController.get = () => {};
    // @ts-ignore
    mockController.get.isEndpoint = true;
    // @ts-ignore
    mockController.get.path = "/resource";
    // @ts-ignore
    mockController.get.method = "get";

    // @ts-ignore
    mockController.post = () => {};
    // @ts-ignore
    mockController.post.isEndpoint = true;
    // @ts-ignore
    mockController.post.path = "/resource";
    // @ts-ignore
    mockController.post.method = "post";

    const registry = { getTargets: () => new Set([mockController]) } as any;
    const spec = generateOpenAPI({}, registry);

    expect(spec.paths["/resource"].get).toBeDefined();
    expect(spec.paths["/resource"].post).toBeDefined();
  });

  it("should handle unknown path and method defaults", () => {
    const mockController = class WeirdController {};
    // @ts-ignore
    mockController.weird = () => {};
    // @ts-ignore
    mockController.weird.isEndpoint = true;
    // Note: missing path and method

    const registry = { getTargets: () => new Set([mockController]) } as any;
    const spec = generateOpenAPI({}, registry);

    expect(spec.paths["/unknown"]).toBeDefined();
    expect(spec.paths["/unknown"].get).toBeDefined();
  });

  it("should convert :param paths to {param} and inject path parameters", () => {
    const mockController = class ParamController {};
    // @ts-ignore
    mockController.getUser = () => {};
    // @ts-ignore
    mockController.getUser.isEndpoint = true;
    // @ts-ignore
    mockController.getUser.path = "/users/:userId/posts/:postId";
    // @ts-ignore
    mockController.getUser.method = "get";

    const registry = { getTargets: () => new Set([mockController]) } as any;
    const spec = generateOpenAPI({}, registry);

    const openApiPath = "/users/{userId}/posts/{postId}";
    expect(spec.paths[openApiPath]).toBeDefined();
    const operation = spec.paths[openApiPath].get;
    expect(operation.parameters).toBeDefined();
    expect(operation.parameters.length).toBe(2);
    expect(operation.parameters[0]).toEqual({
      name: "userId",
      in: "path",
      required: true,
      schema: { type: "string" },
    });
    expect(operation.parameters[1].name).toBe("postId");
  });

  it("should combine automatic path parameters with decorator parameters", () => {
    const mockController = class MixController {};
    // @ts-ignore
    mockController.get = () => {};
    // @ts-ignore
    mockController.get.isEndpoint = true;
    // @ts-ignore
    mockController.get.path = "/items/:id";
    // @ts-ignore
    mockController.get.method = "get";
    // @ts-ignore
    mockController.get.metadata = {
      parameters: [{ name: "filter", in: "query" }]
    };

    const registry = { getTargets: () => new Set([mockController]) } as any;
    const spec = generateOpenAPI({}, registry);

    const operation = spec.paths["/items/{id}"].get;
    expect(operation.parameters).toBeDefined();
    expect(operation.parameters.length).toBe(2);
    expect(operation.parameters[0].name).toBe("id");
    expect(operation.parameters[0].in).toBe("path");
    expect(operation.parameters[1].name).toBe("filter");
    expect(operation.parameters[1].in).toBe("query");
  });

  it("should resolve referenced component schemas via the SCHEMAS symbol", () => {
    const mockController = class SchemaController {};
    // @ts-ignore
    mockController[SCHEMAS] = new Set(["User", "Post"]);

    const registry = { getTargets: () => new Set([mockController]) } as any;
    
    // Provide the schema definitions in options
    const schemas = {
      User: { type: "object", properties: { id: { type: "string" }, profile: { $ref: "#/components/schemas/Profile" } } },
      Post: { type: "object", properties: { title: { type: "string" } } },
      Profile: { type: "object", properties: { age: { type: "integer" } } }, // Transitive ref
      Unused: { type: "object" } // Should not be included
    };

    const spec = generateOpenAPI({ schemas }, registry);

    const resolved = spec.components.schemas;
    expect(resolved["User"]).toBeDefined();
    expect(resolved["Post"]).toBeDefined();
    expect(resolved["Profile"]).toBeDefined(); // Transitively resolved!
    expect(resolved["Unused"]).toBeUndefined();
  });
});
